// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package xdb

import (
	"context"

	"github.com/dogmatiq/persistencekit/driver/sql/postgres/internal/commonschema"
)

const deleteRecords = `-- name: DeleteRecords :exec
DELETE FROM persistencekit.journal_record
WHERE journal_id = $1
AND position < $2
`

type DeleteRecordsParams struct {
	JournalID int64
	End       commonschema.Uint64
}

func (q *Queries) DeleteRecords(ctx context.Context, arg DeleteRecordsParams) error {
	_, err := q.db.ExecContext(ctx, deleteRecords, arg.JournalID, arg.End)
	return err
}

const incrementEnd = `-- name: IncrementEnd :execrows
UPDATE persistencekit.journal
SET "end" = "end" + 1
WHERE id = $1
AND "end" = $2
`

type IncrementEndParams struct {
	JournalID int64
	End       commonschema.Uint64
}

func (q *Queries) IncrementEnd(ctx context.Context, arg IncrementEndParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, incrementEnd, arg.JournalID, arg.End)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const insertRecord = `-- name: InsertRecord :exec
INSERT INTO persistencekit.journal_record (
    journal_id,
    position,
    record
) VALUES (
    $1,
    $2,
    $3
)
`

type InsertRecordParams struct {
	JournalID int64
	Position  commonschema.Uint64
	Record    []byte
}

func (q *Queries) InsertRecord(ctx context.Context, arg InsertRecordParams) error {
	_, err := q.db.ExecContext(ctx, insertRecord, arg.JournalID, arg.Position, arg.Record)
	return err
}

const selectBounds = `-- name: SelectBounds :one
SELECT
    "begin",
    "end"
FROM persistencekit.journal
WHERE id = $1
`

type SelectBoundsRow struct {
	Begin commonschema.Uint64
	End   commonschema.Uint64
}

func (q *Queries) SelectBounds(ctx context.Context, journalID int64) (SelectBoundsRow, error) {
	row := q.db.QueryRowContext(ctx, selectBounds, journalID)
	var i SelectBoundsRow
	err := row.Scan(&i.Begin, &i.End)
	return i, err
}

const selectRecord = `-- name: SelectRecord :one
SELECT
    record
FROM persistencekit.journal_record
WHERE journal_id = $1
AND position = $2
`

type SelectRecordParams struct {
	JournalID int64
	Position  commonschema.Uint64
}

func (q *Queries) SelectRecord(ctx context.Context, arg SelectRecordParams) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, selectRecord, arg.JournalID, arg.Position)
	var record []byte
	err := row.Scan(&record)
	return record, err
}

const selectRecords = `-- name: SelectRecords :many
SELECT
    position,
    record
FROM persistencekit.journal_record
WHERE journal_id = $1
AND position >= $2
ORDER BY position
LIMIT 500
`

type SelectRecordsParams struct {
	JournalID int64
	Position  commonschema.Uint64
}

type SelectRecordsRow struct {
	Position commonschema.Uint64
	Record   []byte
}

func (q *Queries) SelectRecords(ctx context.Context, arg SelectRecordsParams) ([]SelectRecordsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRecords, arg.JournalID, arg.Position)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRecordsRow
	for rows.Next() {
		var i SelectRecordsRow
		if err := rows.Scan(&i.Position, &i.Record); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBegin = `-- name: UpdateBegin :execrows
UPDATE persistencekit.journal
SET "begin" = $1
WHERE id = $2
AND "begin" < $1
`

type UpdateBeginParams struct {
	Begin     commonschema.Uint64
	JournalID int64
}

func (q *Queries) UpdateBegin(ctx context.Context, arg UpdateBeginParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateBegin, arg.Begin, arg.JournalID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const upsertJournal = `-- name: UpsertJournal :one
INSERT INTO persistencekit.journal (
    name
) VALUES (
    $1
) ON CONFLICT (name) DO UPDATE SET
    name = EXCLUDED.name
RETURNING id
`

func (q *Queries) UpsertJournal(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertJournal, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}
